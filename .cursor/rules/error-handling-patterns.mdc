---
description: "Error handling and logging patterns"
globs: *.ts,*.tsx
---

# Error Handling Guidelines

## Error Handling Philosophy
- **Fail fast**: Catch errors early and provide clear feedback
- **User-friendly messages**: Show helpful messages to users, log technical details
- **Graceful degradation**: Provide fallbacks when possible
- **Consistent patterns**: Use the same error handling approach across the codebase

## tRPC Error Handling

### API Error Patterns
```typescript
import { TRPCError } from "@trpc/server";

export const courseRouter = {
  getById: publicProcedure
    .input(courseSelectSchema.pick({ id: true }))
    .query(async ({ input }) => {
      const results = await db
        .select()
        .from(course)
        .where(eq(course.id, input.id))
        .limit(1);

      if (!results[0]) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Course not found",
          cause: new Error(`Course with id ${input.id} does not exist`),
        });
      }

      return results[0];
    }),

  create: protectedProcedure
    .input(courseInsertSchema)
    .mutation(async ({ input, ctx }) => {
      try {
        return await db.insert(course).values({
          ...input,
          instructorId: ctx.user.id,
        }).returning();
      } catch (error) {
        if (error instanceof Error && error.message.includes('duplicate key')) {
          throw new TRPCError({
            code: "CONFLICT",
            message: "A course with this slug already exists",
            cause: error,
          });
        }
        
        throw new TRPCError({
          code: "INTERNAL_SERVER_ERROR",
          message: "Failed to create course",
          cause: error,
        });
      }
    }),
};
```

### Common tRPC Error Codes
- `BAD_REQUEST` - Invalid input data
- `UNAUTHORIZED` - Authentication required
- `FORBIDDEN` - Insufficient permissions
- `NOT_FOUND` - Resource doesn't exist
- `CONFLICT` - Resource already exists or constraint violation
- `INTERNAL_SERVER_ERROR` - Unexpected server errors
- `TOO_MANY_REQUESTS` - Rate limiting

## Client-Side Error Handling

### React Query Error Handling
```typescript
import { toast } from "@lms/ui/components/sonner";

export function CourseList() {
  const { data: courses, error, isError } = api.course.getAll.useQuery();

  if (isError) {
    // Handle different error types
    if (error.data?.code === "UNAUTHORIZED") {
      return <div>Please sign in to view courses</div>;
    }
    
    if (error.data?.code === "FORBIDDEN") {
      return <div>You don't have permission to view courses</div>;
    }

    // Generic error fallback
    return <div>Failed to load courses. Please try again.</div>;
  }

  return (
    <div>
      {courses?.map(course => (
        <CourseCard key={course.id} course={course} />
      ))}
    </div>
  );
}
```

### Form Error Handling
```typescript
import { useForm } from "react-hook-form";
import { toast } from "@lms/ui/components/sonner";

export function CreateCourseForm() {
  const form = useForm<CourseFormData>();
  const createCourse = api.course.create.useMutation({
    onSuccess: () => {
      toast.success("Course created successfully!");
      form.reset();
    },
    onError: (error) => {
      if (error.data?.code === "CONFLICT") {
        form.setError("slug", {
          message: "This course slug is already taken",
        });
      } else {
        toast.error("Failed to create course. Please try again.");
      }
    },
  });

  const onSubmit = async (data: CourseFormData) => {
    try {
      await createCourse.mutateAsync(data);
    } catch (error) {
      // Error is already handled by onError callback
      console.error("Course creation failed:", error);
    }
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)}>
        {/* Form fields */}
      </form>
    </Form>
  );
}
```

## Database Error Handling

### Drizzle Error Patterns
```typescript
import { eq } from "@lms/db";
import { db } from "@lms/db/client";

export async function updateCourse(id: string, data: Partial<Course>) {
  try {
    const result = await db
      .update(course)
      .set(data)
      .where(eq(course.id, id))
      .returning();

    if (result.length === 0) {
      throw new Error(`Course with id ${id} not found`);
    }

    return result[0];
  } catch (error) {
    if (error instanceof Error) {
      // Handle specific database errors
      if (error.message.includes('foreign key constraint')) {
        throw new Error('Cannot update course: referenced by other records');
      }
      
      if (error.message.includes('unique constraint')) {
        throw new Error('Course slug must be unique');
      }
    }
    
    // Re-throw unknown errors
    throw error;
  }
}
```

## Authentication Error Handling

### Auth Error Patterns
```typescript
import { signIn } from "~/auth/client";

export function LoginForm() {
  const [error, setError] = useState<string | null>(null);

  const handleSignIn = async (data: LoginFormData) => {
    try {
      setError(null);
      await signIn.email({
        email: data.email,
        password: data.password,
        callbackURL: "/dashboard",
      });
    } catch (error) {
      if (error instanceof Error) {
        // Handle specific auth errors
        if (error.message.includes("Invalid credentials")) {
          setError("Invalid email or password");
        } else if (error.message.includes("Too many requests")) {
          setError("Too many login attempts. Please try again later.");
        } else {
          setError("An unexpected error occurred. Please try again.");
        }
      }
    }
  };

  return (
    <form onSubmit={handleSubmit(handleSignIn)}>
      {error && (
        <div className="text-destructive text-sm mb-4">
          {error}
        </div>
      )}
      {/* Form fields */}
    </form>
  );
}
```

## Error Boundaries

### React Error Boundary
```typescript
import { Component, type ReactNode } from "react";

interface ErrorBoundaryState {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends Component<
  { children: ReactNode; fallback?: ReactNode },
  ErrorBoundaryState
> {
  constructor(props: { children: ReactNode; fallback?: ReactNode }) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error("Error caught by boundary:", error, errorInfo);
    // Log to error reporting service
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback || (
        <div className="p-4 text-center">
          <h2 className="text-lg font-semibold mb-2">Something went wrong</h2>
          <p className="text-muted-foreground">
            Please refresh the page or try again later.
          </p>
        </div>
      );
    }

    return this.props.children;
  }
}
```

## Logging Patterns

### Server-Side Logging
```typescript
// Use structured logging
console.error("Course creation failed", {
  userId: ctx.user.id,
  input: input,
  error: error.message,
  timestamp: new Date().toISOString(),
});

// For production, use a proper logging service
// logger.error("Course creation failed", {
//   userId: ctx.user.id,
//   error: error.message,
//   stack: error.stack,
// });
```

### Client-Side Error Reporting
```typescript
// Log client errors for debugging
if (process.env.NODE_ENV === "development") {
  console.error("API call failed:", {
    endpoint: "course.create",
    error: error.message,
    data: error.data,
  });
}

// In production, send to error reporting service
// errorReporter.captureException(error, {
//   tags: { component: "CreateCourseForm" },
//   extra: { formData: data },
// });
```

## Validation Error Handling

### Zod Validation Errors
```typescript
import { z } from "zod/v4";

const schema = z.object({
  email: z.string().email("Please enter a valid email address"),
  password: z.string().min(8, "Password must be at least 8 characters"),
});

try {
  const result = schema.parse(data);
} catch (error) {
  if (error instanceof z.ZodError) {
    // Handle validation errors
    error.errors.forEach((err) => {
      form.setError(err.path[0] as keyof FormData, {
        message: err.message,
      });
    });
  }
}
```

## Best Practices

### Error Message Guidelines
- **Be specific**: "Course not found" vs "An error occurred"
- **Be actionable**: Tell users what they can do next
- **Be consistent**: Use the same tone and format across the app
- **Be secure**: Don't expose sensitive information in error messages

### Error Recovery
- Provide retry mechanisms for transient errors
- Offer alternative actions when possible
- Save user input when errors occur
- Show loading states during error recovery

### Monitoring and Alerting
- Log all server errors with context
- Monitor error rates and patterns
- Set up alerts for critical error thresholds
- Track user-facing errors separately from system errors